@ExtendWith(MockitoExtension.class)
class ArchLobStorageMappingServiceTest {

    @Mock
    private ArchLobStorageConfigRepository repo; // replace with actual repo interface name

    @InjectMocks
    private ArchLobStorageMappingService service;

    @Test
    void testDeleteArchivalConfig_success() {
        String id = "1";
        ArchLobStorageConfig mockEntity = new ArchLobStorageConfig();
        ArchivalStorageConfigObj inputObj = new ArchivalStorageConfigObj();

        // Mock repository behavior
        when(repo.findById(1L)).thenReturn(Optional.of(mockEntity));
        // Mock getMismatches to return all TRUEs
        Map<String, Boolean> mockMismatchMap = Map.of("field1", true, "field2", true);
        Mockito.doReturn(mockMismatchMap).when(service).getMismatches(inputObj, Optional.of(mockEntity));

        service.deleteArchivalConfig(id, inputObj);

        verify(repo).deleteById(1L);
    }

    @Test
    void testDeleteArchivalConfig_notFound() {
        String id = "2";
        ArchivalStorageConfigObj inputObj = new ArchivalStorageConfigObj();

        when(repo.findById(2L)).thenReturn(Optional.empty());

        assertThrows(NoSuchElementException.class, () ->
            service.deleteArchivalConfig(id, inputObj)
        );
    }

    @Test
    void testDeleteArchivalConfig_mismatchFound() {
        String id = "3";
        ArchLobStorageConfig mockEntity = new ArchLobStorageConfig();
        ArchivalStorageConfigObj inputObj = new ArchivalStorageConfigObj();

        when(repo.findById(3L)).thenReturn(Optional.of(mockEntity));
        Map<String, Boolean> mockMismatchMap = Map.of("lobId", false);
        Mockito.doReturn(mockMismatchMap).when(service).getMismatches(inputObj, Optional.of(mockEntity));

        assertThrows(IllegalStateException.class, () ->
            service.deleteArchivalConfig(id, inputObj)
        );
    }
}