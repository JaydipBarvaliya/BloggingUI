@ExtendWith(MockitoExtension.class)
public class ArchivalApiMetadataServiceTest {

    @InjectMocks
    private ArchivalApiMetadataService archivalApiMetadataService;

    @Mock
    private MetaRepository metaRepo;

    @Test
    void testDeleteArchivalMetadataMapping_MismatchConditions() {
        // Given
        String id = "123";
        
        ArchMetadataMapping entity = new ArchMetadataMapping();
        entity.setMapType("TypeA");         // Expected match
        entity.setArcKey("KeyA");           // Expected match
        entity.setArcDescription("DescA");  // Expected mismatch
        entity.setArcValue("ValueA");       // Expected mismatch

        ArchivalMetadataMappingObj deletionMetadata = new ArchivalMetadataMappingObj();
        deletionMetadata.setMapType("TypeA");        // Matching
        deletionMetadata.setArcKey("KeyA");          // Matching
        deletionMetadata.setArcDescription("DescB"); // Mismatch
        deletionMetadata.setArcValue("ValueB");      // Mismatch

        when(metaRepo.findById(Long.valueOf(id))).thenReturn(Optional.of(entity));

        // When & Then
        Exception exception = assertThrows(Exception.class, 
            () -> archivalApiMetadataService.deleteArchivalMetadataMapping(id, deletionMetadata));

        assertEquals("Data available but mismatch.", exception.getMessage());

        // Verify that deleteById was **never** called due to mismatched conditions
        verify(metaRepo, never()).deleteById(any());
    }
}