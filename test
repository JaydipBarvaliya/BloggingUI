public static int minRetailersToRelocate(List<Integer> regionStart, List<Integer> regionEnd) {
    int n = regionStart.size();
    int[][] intervals = new int[n][2];

    for (int i = 0; i < n; i++) {
        intervals[i][0] = regionStart.get(i);
        intervals[i][1] = regionEnd.get(i);
    }

    // Sort by start time
    Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));

    // Track max inclusive group
    int maxGroup = 1;

    // Use a TreeMap to keep end frequencies for efficient window
    TreeMap<Integer, Integer> endCounts = new TreeMap<>();
    int left = 0;

    for (int right = 0; right < n; right++) {
        // Add current end to map
        endCounts.put(intervals[right][1], endCounts.getOrDefault(intervals[right][1], 0) + 1);

        // While intersection is invalid, move left pointer
        while (intervals[right][0] > endCounts.firstKey()) {
            int end = intervals[left][1];
            endCounts.put(end, endCounts.get(end) - 1);
            if (endCounts.get(end) == 0) endCounts.remove(end);
            left++;
        }

        maxGroup = Math.max(maxGroup, right - left + 1);
    }

    return n - maxGroup;
}