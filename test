import java.text.MessageFormat;
import java.util.Map;
import java.util.Optional;
import java.util.Objects;

public void deleteArchivalMetadataMapping(String id, ArchivalMetadataMappingObj deletionMetadata) throws Exception {
    Optional<ArchivalMetadataMapping> entity = this.metaRepo.findById(Long.valueOf(id));

    if (entity.isEmpty()) {
        log.error("Data not available to delete for id {}", id);
        throw new Exception(MessageFormat.format("Data not available to delete for id={0}", id));
    }

    ArchivalMetadataMapping entityObj = entity.get();

    // Store fields to compare in a map
    Map<String, Boolean> mismatches = Map.of(
        "mapType", Objects.equals(entityObj.getMapType(), deletionMetadata.getMapType()),
        "arcKey", Objects.equals(entityObj.getArcKey(), deletionMetadata.getArcKey()),
        "arcDescription", Objects.equals(entityObj.getArcDescription(), deletionMetadata.getArcDescription()),
        "arcValue", Objects.equals(entityObj.getArcValue(), deletionMetadata.getArcValue())
    );

    // Find the first mismatch and throw an exception
    for (Map.Entry<String, Boolean> entry : mismatches.entrySet()) {
        if (!entry.getValue()) {
            log.error("Data available but mismatch in {}", entry.getKey());
            throw new Exception("Data available but mismatch in " + entry.getKey());
        }
    }

    // Proceed with deletion
    this.metaRepo.deleteById(Long.valueOf(id));
    log.debug("Record deleted successfully for id {}", id);
}